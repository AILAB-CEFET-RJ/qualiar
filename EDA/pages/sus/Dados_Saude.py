import streamlit as st
import pandas as pd
import plotly.express as px
import plotly.graph_objects as go
import numpy as np
from datetime import datetime

def show(df_sus, df_sus_aggregated, month_names):
    st.title("ü©∫ Dados de Sa√∫de - Interna√ß√µes por Doen√ßas Respirat√≥rias")
    
    # Adicionando informa√ß√µes sobre o dataset
    with st.expander("‚ÑπÔ∏è Sobre os dados"):
        st.markdown("""
        Este dataset cont√©m informa√ß√µes de hospitaliza√ß√µes por doen√ßas respirat√≥rias na cidade do Rio de Janeiro.
        Cada linha representa uma interna√ß√£o com as seguintes informa√ß√µes:
        - **Data de interna√ß√£o** e **sa√≠da**
        - **Idade** e **sexo** do paciente
        - **Diagn√≥sticos** principal e secund√°rios
        - **Dura√ß√£o** da interna√ß√£o
        - **√ìbito** (se ocorreu)
        """)
    
    # --- SE√á√ÉO 1: VIS√ÉO GERAL ---
    st.header("üìä Vis√£o Geral das Interna√ß√µes")
    
    # Criar colunas para os KPIs
    col1, col2, col3, col4 = st.columns(4)
    
    # Calcular m√©tricas
    total_internacoes = df_sus.shape[0]
    media_idade = df_sus['IDADE'].mean()
    taxa_mortalidade = df_sus['MORTE'].mean() * 100
    media_permanencia = df_sus['DIAS_PERM'].mean()
    
    # Exibir KPIs
    col1.metric("Total de Interna√ß√µes", f"{total_internacoes:,}".replace(",", "."))
    col2.metric("M√©dia de Idade", f"{media_idade:.1f} anos")
    col3.metric("Taxa de Mortalidade", f"{taxa_mortalidade:.2f}%")
    col4.metric("M√©dia de Perman√™ncia", f"{media_permanencia:.1f} dias")
    
    # --- SE√á√ÉO 2: AN√ÅLISE TEMPORAL ---
    st.header("üìà An√°lise Temporal")
    
    # Gr√°fico de linhas - Interna√ß√µes por m√™s/ano
    fig = px.line(df_sus_aggregated, 
                 x='mes_ano', 
                 y='num_internacoes',
                 title='N√∫mero de Interna√ß√µes por M√™s/Ano',
                 labels={'mes_ano': 'M√™s/Ano', 'num_internacoes': 'N√∫mero de Interna√ß√µes'},
                 markers=True)
    
    fig.update_layout(
        xaxis_title='M√™s/Ano',
        yaxis_title='N√∫mero de Interna√ß√µes',
        hovermode="x unified",
        height=500
    )
    
    st.plotly_chart(fig, use_container_width=True)
    
    # --- SE√á√ÉO 3: FILTROS E AN√ÅLISE DETALHADA ---
    st.header("üîç An√°lise Detalhada")
    
    # Criar abas para diferentes an√°lises
    tab1, tab2, tab3, tab4, tab5 = st.tabs(["Por Idade", "Por Sexo", "Por Diagn√≥stico", "Mortalidade", "Top Causas de Morte"])
    
    with tab1:
        # An√°lise por idade
        st.subheader("Distribui√ß√£o por Idade")
        
        # Criar faixas et√°rias
        bins = [0, 5, 12, 18, 30, 50, 65, 100]
        labels = ['0-5', '6-12', '13-18', '19-30', '31-50', '51-65', '66+']
        df_sus['faixa_etaria'] = pd.cut(df_sus['IDADE'], bins=bins, labels=labels, right=False)
        
        # Agrupar por faixa et√°ria
        df_idade = df_sus.groupby('faixa_etaria').size().reset_index(name='count')
        
        # Gr√°fico de barras
        fig = px.bar(df_idade, 
                    x='faixa_etaria', 
                    y='count',
                    title='Interna√ß√µes por Faixa Et√°ria',
                    labels={'faixa_etaria': 'Faixa Et√°ria', 'count': 'N√∫mero de Interna√ß√µes'})
        
        st.plotly_chart(fig, use_container_width=True)
    
    with tab2:
        # An√°lise por sexo
        st.subheader("Distribui√ß√£o por Sexo")
        
        # Traduzir c√≥digos de sexo
        sexo_map = {1: 'Masculino', 3: 'Feminino'}
        df_sus['sexo_desc'] = df_sus['SEXO'].map(sexo_map)
        
        # Agrupar por sexo
        df_sexo = df_sus.groupby('sexo_desc').size().reset_index(name='count')
        
        # Gr√°fico de pizza
        fig = px.pie(df_sexo, 
                    values='count', 
                    names='sexo_desc',
                    title='Propor√ß√£o de Interna√ß√µes por Sexo',
                    hole=0.3)
        
        st.plotly_chart(fig, use_container_width=True)
    
    with tab3:
        # An√°lise por diagn√≥stico
        st.subheader("Principais Diagn√≥sticos")
        
        # Contar diagn√≥sticos principais
        top_diag = df_sus['DIAG_PRINC'].value_counts().head(10).reset_index()
        top_diag.columns = ['diagnostico', 'count']
        
        # Gr√°fico de barras horizontais
        fig = px.bar(top_diag, 
                    y='diagnostico', 
                    x='count',
                    orientation='h',
                    title='Top 10 Diagn√≥sticos Principais',
                    labels={'diagnostico': 'C√≥digo CID-10', 'count': 'N√∫mero de Interna√ß√µes'})
        
        fig.update_layout(yaxis={'categoryorder':'total ascending'})
        st.plotly_chart(fig, use_container_width=True)
    
    with tab4:
        # An√°lise de mortalidade
        st.subheader("An√°lise de Mortalidade")
        
        # Agrupar por m√™s/ano e calcular taxa de mortalidade
        df_mortalidade = df_sus.groupby(['ANO_CMPT', 'MES_CMPT']).agg(
            total_internacoes=('MORTE', 'size'),
            total_obitos=('MORTE', 'sum')
        ).reset_index()
        
        df_mortalidade['taxa_mortalidade'] = (df_mortalidade['total_obitos'] / df_mortalidade['total_internacoes']) * 100
        df_mortalidade['mes_ano'] = df_mortalidade['ANO_CMPT'].astype(str) + '-' + df_mortalidade['MES_CMPT'].astype(str)
        
        # Gr√°fico de linhas
        fig = px.line(df_mortalidade, 
                     x='mes_ano', 
                     y='taxa_mortalidade',
                     title='Taxa de Mortalidade por M√™s/Ano (%)',
                     labels={'mes_ano': 'M√™s/Ano', 'taxa_mortalidade': 'Taxa de Mortalidade (%)'},
                     markers=True)
        
        st.plotly_chart(fig, use_container_width=True)
    
    with tab5:
      st.subheader("Top 10 Causas de Morte")
      
      # Filtrar apenas √≥bitos e contar diagn√≥sticos principais
      df_obitos = df_sus[df_sus['MORTE'] == 1]
      top_causas_morte = df_obitos['DIAG_PRINC'].value_counts().head(10).reset_index()
      top_causas_morte.columns = ['diagnostico', 'obitos']
      
      if len(top_causas_morte) > 0:
          # Calcular total de interna√ß√µes por diagn√≥stico (incluindo n√£o-√≥bitos)
          total_internacoes_diag = df_sus['DIAG_PRINC'].value_counts().reset_index()
          total_internacoes_diag.columns = ['diagnostico', 'total_internacoes']
          
          # Juntar os dados
          df_mortalidade_diag = pd.merge(top_causas_morte, total_internacoes_diag, on='diagnostico', how='left')
          
          # Calcular taxa de mortalidade
          df_mortalidade_diag['taxa_mortalidade'] = (df_mortalidade_diag['obitos'] / df_mortalidade_diag['total_internacoes']) * 100
          
          # Ordenar por n√∫mero de √≥bitos
          df_mortalidade_diag = df_mortalidade_diag.sort_values('obitos', ascending=True)
          
          # Criar gr√°fico de barras
          fig = go.Figure()
          
          fig.add_trace(go.Bar(
              y=df_mortalidade_diag['diagnostico'],
              x=df_mortalidade_diag['obitos'],
              name='√ìbitos',
              orientation='h',
              marker_color='#EF553B',
              text=[f"{rate:.1f}%" for rate in df_mortalidade_diag['taxa_mortalidade']],
              textposition='outside'
          ))
          
          # Configura√ß√µes do layout
          fig.update_layout(
              title='Top 10 Causas de Morte por Doen√ßas Respirat√≥rias',
              yaxis=dict(
                  title='C√≥digo CID-10'
              ),
              xaxis=dict(
                  title='N√∫mero de √ìbitos'
              ),
              height=500,
              showlegend=False,
              margin=dict(l=100, r=50, t=80, b=50)
          )
          
          st.plotly_chart(fig, use_container_width=True)
          
          # Adicionar tabela com os dados detalhados (formatada)
          with st.expander("üìä Ver dados detalhados"):
              df_detalhes = df_mortalidade_diag.sort_values('obitos', ascending=False)
              df_detalhes['taxa_mortalidade'] = df_detalhes['taxa_mortalidade'].map("{:.1f}%".format)
              st.dataframe(df_detalhes[['diagnostico', 'obitos', 'total_internacoes', 'taxa_mortalidade']]
                          .rename(columns={
                              'diagnostico': 'Diagn√≥stico',
                              'obitos': '√ìbitos',
                              'total_internacoes': 'Total Interna√ß√µes',
                              'taxa_mortalidade': 'Taxa Mortalidade'
                          }))
      else:
          st.warning("N√£o h√° registros de √≥bitos no per√≠odo selecionado.")
    # --- SE√á√ÉO 4: FILTROS INTERATIVOS ---
    st.header("üéöÔ∏è Filtros Interativos")
    
    # Criar colunas para os filtros
    col1, col2, col3 = st.columns(3)
    
    with col1:
        anos = sorted(df_sus['ANO_CMPT'].unique())
        ano_selecionado = st.selectbox('Selecione o ano:', ['Todos'] + anos)
    
    with col2:
        meses = sorted(df_sus['MES_CMPT'].unique())
        mes_selecionado = st.selectbox('Selecione o m√™s:', ['Todos'] + meses, format_func=lambda x: month_names[x] if x != 'Todos' else x)
    
    with col3:
        sexos = ['Todos'] + sorted(df_sus['SEXO'].unique())
        sexo_selecionado = st.selectbox('Selecione o sexo:', sexos, format_func=lambda x: {1: 'Masculino', 2: 'Feminino', 3: 'Indeterminado'}.get(x, 'Todos'))
    
    # Aplicar filtros
    df_filtrado = df_sus.copy()
    
    if ano_selecionado != 'Todos':
        df_filtrado = df_filtrado[df_filtrado['ANO_CMPT'] == ano_selecionado]
    
    if mes_selecionado != 'Todos':
        df_filtrado = df_filtrado[df_filtrado['MES_CMPT'] == mes_selecionado]
    
    if sexo_selecionado != 'Todos':
        df_filtrado = df_filtrado[df_filtrado['SEXO'] == sexo_selecionado]
    
    # Exibir estat√≠sticas filtradas
    st.subheader("Estat√≠sticas Filtradas")
    
    # Criar colunas para os KPIs filtrados
    col1, col2, col3, col4 = st.columns(4)
    
    total_filtrado = df_filtrado.shape[0]
    media_idade_filtrado = df_filtrado['IDADE'].mean()
    taxa_mortalidade_filtrado = df_filtrado['MORTE'].mean() * 100 if total_filtrado > 0 else 0
    media_permanencia_filtrado = df_filtrado['DIAS_PERM'].mean()
    
    col1.metric("Total de Interna√ß√µes", f"{total_filtrado:,}".replace(",", "."), delta=f"{total_filtrado - total_internacoes:,}" if total_filtrado != total_internacoes else None)
    col2.metric("M√©dia de Idade", f"{media_idade_filtrado:.1f} anos", delta=f"{media_idade_filtrado - media_idade:.1f}" if total_filtrado != total_internacoes else None)
    col3.metric("Taxa de Mortalidade", f"{taxa_mortalidade_filtrado:.2f}%", delta=f"{taxa_mortalidade_filtrado - taxa_mortalidade:.2f}%" if total_filtrado != total_internacoes else None)
    col4.metric("M√©dia de Perman√™ncia", f"{media_permanencia_filtrado:.1f} dias", delta=f"{media_permanencia_filtrado - media_permanencia:.1f}" if total_filtrado != total_internacoes else None)
    
    # Exibir dataframe filtrado
    with st.expander("üîé Visualizar Dados Filtrados"):
        st.dataframe(df_filtrado.head(100))
    
    # --- SE√á√ÉO 5: DOWNLOAD DOS DADOS ---
    st.header("üì• Download dos Dados")
    
    # Op√ß√µes de download
    col1, col2 = st.columns(2)
    
    with col1:
        st.download_button(
            label="Baixar Dados Completos (CSV)",
            data=df_sus.to_csv(index=False).encode('utf-8'),
            file_name='internacoes_respiratorias_rj_completo.csv',
            mime='text/csv'
        )
    
    with col2:
        st.download_button(
            label="Baixar Dados Filtrados (CSV)",
            data=df_filtrado.to_csv(index=False).encode('utf-8'),
            file_name='internacoes_respiratorias_rj_filtrado.csv',
            mime='text/csv'
        )